<!-- Full Name: Thai Binh Nguyen
   Course: CS 442
   Professor: Dr. Grant Williams
   Date: 10/03/2023
-->

<!DOCTYPE html>
<html>
    <!-- Applying styles for the canvas -->
    <style>
        #the-canvas {
            border: 1px solid darkblue;
        }
    </style>

    <head>
        <title>Project 6: Camera</title>
    </head>

    <body>
        <!-- Defining a canvas element with id 'the-canvas' -->
        <canvas id="the-canvas" width="800" height="500"></canvas>

        <script src="./mesh_template.js"> </script>
        <script src="./matrix.js"> </script>

        <script>
            // Initialize WebGL context
            let canvas = document.getElementById('the-canvas');
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext('webgl2');

            // Clearing the canvas with specific color
            gl.clearColor(128 / 255, 204 / 255, 255 / 255, 1);
            
            // Vertex Shader
            let vertex_source = 
            `#version 300 es
                precision mediump float;
                uniform mat4 modelview; // this is the matrix
                in vec3 coordinates;
                void main( void ) {
                    gl_Position = modelview * vec4(coordinates, 1.0);
                }`;

            let fragment_source = 
            `#version 300 es
                precision mediump float;
                out vec4 f_color;  // Declare f_color
                void main(void) {
                    /* we can test depth values with this.*/
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0);
                }`;
                


            // Creating the Vertex and Fragment shaders
            let vert_shader = gl.createShader( gl.VERTEX_SHADER );
            let frag_shader = gl.createShader( gl.FRAGMENT_SHADER );

            // Providing the source code to shaders
            gl.shaderSource(vert_shader, vertex_source);
            gl.shaderSource(frag_shader, fragment_source);

            // Compiling the shaders
            gl.compileShader(vert_shader);
            gl.compileShader(frag_shader);
            
            // Creating a shader program and linking shaders to it
            let shader_program = gl.createProgram();
            gl.attachShader(shader_program, vert_shader);
            gl.attachShader(shader_program, frag_shader);
            gl.linkProgram(shader_program);

            // Using the created program
            gl.useProgram(shader_program);  

            class Keys {
                constructor() {
                    this.keys_down = {};
                }
            
                static start_listening() {
                    let keys = new Keys();
            
                    addEventListener('keydown', function(ev) {
                        if (typeof ev.code === 'string') {
                            keys.keys_down[ev.code] = true;
                        }
                    });
            
                    addEventListener('keyup', function(ev) {
                        if (typeof ev.code === 'string') {
                            keys.keys_down[ev.code] = false;
                        }
                    });
            
                    return keys;
                }
            
                is_key_down(code) {
                    return !!this.keys_down[code];
                }
            
                is_key_up(code) {
                    return !this.keys_down[code];
                }
            
                keys_down_list() {
                    return Object.entries(this.keys_down)
                        .filter(kv => kv[1])  // filter by value (true)
                        .map(kv => kv[0]);    // map to key
                }
            }
            
            function set_uniform_matrix4(gl, program, name, data) {
                const loc = gl.getUniformLocation(program, name);
                gl.uniformMatrix4fv(loc, true, data);
            }

            // Create a projection matrix
            let fov = Math.PI/2; // 90 degrees
            let aspect = canvas.width / canvas.height;
            let near = 0.1;
            let far = 101;

            let topp = near * Math.tan(fov * 0.5);
            let bottom = -topp;
            let right = topp * aspect;
            let left = -right;

            let projectionMatrix = Mat4.frustum(left, right, bottom, topp, near, far);

            let camera = Mat4.identity().mul(Mat4.translation(0,0,-1.5));

            let mesh = Mesh.box(gl, shader_program, 1, 1, 1);

            let key = Keys.start_listening();
            
            setInterval(update, 1000/60)
            function update() {
                if (key.is_key_down('KeyA')) {
                    camera = camera.mul(Mat4.translation(-0.02, 0, 0));
                }
                if (key.is_key_down('KeyD')) {
                    camera = camera.mul(Mat4.translation(0.02, 0, 0));
                }
                if (key.is_key_down('KeyW')) {
                    camera = camera.mul(Mat4.translation(0, 0, 0.02));
                }
                if (key.is_key_down('KeyS')) {
                    camera = camera.mul(Mat4.translation(0, 0, -0.02));
                }
                if (key.is_key_down('Space')) {
                    camera = camera.mul(Mat4.translation(0, 0.02, 0));
                }
                if (key.is_key_down('KeyC')) {
                    camera = camera.mul(Mat4.translation(0, -0.02, 0));
                }
                if (key.is_key_down('KeyQ')) {
                    camera = camera.mul(Mat4.rotation_xy(-0.02));
                }
                
                if (key.is_key_down('KeyE')) {
                    camera = camera.mul(Mat4.rotation_xy(0.02));
                }
                
                if (key.is_key_down('ArrowLeft')) {
                    camera = camera.mul(Mat4.rotation_xz(-0.02));
                }
                
                if (key.is_key_down('ArrowRight')) {
                    camera = camera.mul(Mat4.rotation_xz(0.02));
                }
                
                if (key.is_key_down('ArrowUp')) {
                    camera = camera.mul(Mat4.rotation_yz(-0.02));
                }
                
                if (key.is_key_down('ArrowDown')) {
                    camera = camera.mul(Mat4.rotation_yz(0.02));
                }
            }
            
            requestAnimationFrame(render);
            
            function render() {

                requestAnimationFrame(render); // Call the render function again

                gl.enable(gl.DEPTH_TEST);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                let model = projectionMatrix.mul(camera.inverse());

                // Update the shader uniform
                set_uniform_matrix4(gl, shader_program, "modelview", model.data);
                
                mesh.render(gl);
            }
        </script>
    </body>
</html>