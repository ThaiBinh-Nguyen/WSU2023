<!-- Full Name: Thai Binh Nguyen
   Course: CS 442
   Professor: Dr. Grant Williams
   Date: 10/03/2023
-->

<!DOCTYPE html>
<html>
    <!-- Applying styles for the canvas -->
    <style>
        #the-canvas {
            border: 1px solid darkblue;
        }
    </style>

    <head>
        <title>Project 6: Camera</title>
    </head>

    <body>
        <!-- Defining a canvas element with id 'the-canvas' -->
        <canvas id="the-canvas" width="800" height="500"></canvas>

        <script src="./mesh_template.js"> </script>

        <script>
            // Initialize WebGL context
            let canvas = document.getElementById('the-canvas');
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext('webgl2');
            
            // Clearing the canvas with specific color
            gl.clearColor(128 / 255, 204 / 255, 255 / 255, 1);

            // Vertex Shader
            let vertex_source = 
            `#version 300 es
                precision mediump float;
                uniform mat4 modelview; // this is the matrix
                in vec3 coordinates;
                void main( void ) {
                    gl_Position = modelview * vec4(coordinates, 1.0);
                }`;

            let fragment_source = 
            `#version 300 es
                precision mediump float;
                out vec4 f_color;  // Declare f_color
                void main(void) {
                    /* we can test depth values with this.*/
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0);
                }`;
                


            // Creating the Vertex and Fragment shaders
            let vert_shader = gl.createShader( gl.VERTEX_SHADER );
            let frag_shader = gl.createShader( gl.FRAGMENT_SHADER );

            // Providing the source code to shaders
            gl.shaderSource(vert_shader, vertex_source);
            gl.shaderSource(frag_shader, fragment_source);

            // Compiling the shaders
            gl.compileShader(vert_shader);
            gl.compileShader(frag_shader);
            
            // Creating a shader program and linking shaders to it
            let shader_program = gl.createProgram();
            gl.attachShader(shader_program, vert_shader);
            gl.attachShader(shader_program, frag_shader);
            gl.linkProgram(shader_program);

            // Using the created program
            gl.useProgram(shader_program);     

            class Keys {
                constructor() {
                    this.keys_down = {};
                }
            
                static start_listening() {
                    let keys = new Keys();
            
                    addEventListener('keydown', function(ev) {
                        if (typeof ev.code === 'string') {
                            keys.keys_down[ev.code] = true;
                        }
                    });
            
                    addEventListener('keyup', function(ev) {
                        if (typeof ev.code === 'string') {
                            keys.keys_down[ev.code] = false;
                        }
                    });
            
                    return keys;
                }
            
                is_key_down(code) {
                    return !!this.keys_down[code];
                }
            
                is_key_up(code) {
                    return !this.keys_down[code];
                }
            
                keys_down_list() {
                    return Object.entries(this.keys_down)
                        .filter(kv => kv[1])  // filter by value (true)
                        .map(kv => kv[0]);    // map to key
                }
            }
            
            class Mat4 {
                constructor( data ) {
                    if( data == null ) {
                        this.data = [
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1,
                        ]
                    }
                    else {
                        this.data = data;
                    }
                }
                static identity() {
                    return new Mat4();
                }

                inverse() {
                    // var A2323 = m.m22 * m.m33 - m.m23 * m.m32 ;
                    const A2323 = this.rc(2, 2) * this.rc(3, 3) - this.rc(2, 3) * this.rc(3, 2); 
                    
                    // var A1323 = m.m21 * m.m33 - m.m23 * m.m31 ;
                    const A1323 = this.rc(2, 1) * this.rc(3, 3) - this.rc(2, 3) * this.rc(3, 1);
                    
                    // var A1223 = m.m21 * m.m32 - m.m22 * m.m31 ;
                    const A1223 = this.rc(2, 1) * this.rc(3, 2) - this.rc(2, 2) * this.rc(3, 1);

                    // var A0323 = m.m20 * m.m33 - m.m23 * m.m30 ;
                    const A0323 = this.rc(2, 0) * this.rc(3, 3) - this.rc(2, 3) * this.rc(3, 0);

                    // var A0223 = m.m20 * m.m32 - m.m22 * m.m30 ;
                    const A0223 = this.rc(2, 0) * this.rc(3, 2) - this.rc(2, 2) * this.rc(3, 0);

                    // var A0123 = m.m20 * m.m31 - m.m21 * m.m30 ;
                    const A0123 = this.rc(2, 0) * this.rc(3, 1) - this.rc(2, 1) * this.rc(3, 0);

                    // var A2313 = m.m12 * m.m33 - m.m13 * m.m32 ;
                    const A2313 = this.rc(1, 2) * this.rc(3, 3) - this.rc(1, 3) * this.rc(3, 2);

                    // var A1313 = m.m11 * m.m33 - m.m13 * m.m31 ;
                    const A1313 = this.rc(1, 1) * this.rc(3, 3) - this.rc(1, 3) * this.rc(3, 1);

                    // var A1213 = m.m11 * m.m32 - m.m12 * m.m31 ;
                    const A1213 = this.rc(1, 1) * this.rc(3, 2) - this.rc(1, 2) * this.rc(3, 1);

                    // var A2312 = m.m12 * m.m23 - m.m13 * m.m22 ;
                    const A2312 = this.rc(1, 2) * this.rc(2, 3) - this.rc(1, 3) * this.rc(2, 2);

                    // var A1312 = m.m11 * m.m23 - m.m13 * m.m21 ;
                    const A1312 = this.rc(1, 1) * this.rc(2, 3) - this.rc(1, 3) * this.rc(2, 1);

                    // var A1212 = m.m11 * m.m22 - m.m12 * m.m21 ;
                    const A1212 = this.rc(1, 1) * this.rc(2, 2) - this.rc(1, 2) * this.rc(2, 1);

                    // var A0313 = m.m10 * m.m33 - m.m13 * m.m30 ;
                    const A0313 = this.rc(1, 0) * this.rc(3, 3) - this.rc(1, 3) * this.rc(3, 0);

                    // var A0213 = m.m10 * m.m32 - m.m12 * m.m30 ;
                    const A0213 = this.rc(1, 0) * this.rc(3, 2) - this.rc(1, 2) * this.rc(3, 0);
                    
                    // var A0312 = m.m10 * m.m23 - m.m13 * m.m20 ;
                    const A0312 = this.rc(1, 0) * this.rc(2, 3) - this.rc(1, 3) * this.rc(2, 0);

                    // var A0212 = m.m10 * m.m22 - m.m12 * m.m20 ;
                    const A0212 = this.rc(1, 0) * this.rc(2, 2) - this.rc(1, 2) * this.rc(2, 0);

                    // var A0113 = m.m10 * m.m31 - m.m11 * m.m30 ;
                    const A0113 = this.rc(1, 0) * this.rc(3, 1) - this.rc(1, 1) * this.rc(3, 0);
                    
                    // var A0112 = m.m10 * m.m21 - m.m11 * m.m20 ;
                    const A0112 = this.rc(1, 0) * this.rc(2, 1) - this.rc(1, 1) * this.rc(2, 0);
                    

                    const det = 
                    this.rc(0, 0) * ( this.rc(1, 1) * A2323 - this.rc(1, 2) * A1323 + this.rc(1, 3) * A1223 ) -
                    this.rc(0, 1) * ( this.rc(1, 0) * A2323 - this.rc(1, 2) * A0323 + this.rc(1, 3) * A0223 ) +
                    this.rc(0, 2) * ( this.rc(1, 0) * A1323 - this.rc(1, 1) * A0323 + this.rc(1, 3) * A0123 ) -
                    this.rc(0, 3) * ( this.rc(1, 0) * A1223 - this.rc(1, 1) * A0223 + this.rc(1, 2) * A0123 );

                    const dr = 1.0 / det;

                    return new Mat4( [
                        dr * ( this.rc(1, 1) * A2323 - this.rc(1, 2) * A1323 + this.rc(1, 3) * A1223 ),
                        dr *-( this.rc(0, 1) * A2323 - this.rc(0, 2) * A1323 + this.rc(0, 3) * A1223 ),
                        dr * ( this.rc(0, 1) * A2313 - this.rc(0, 2) * A1313 + this.rc(0, 3) * A1213 ),
                        dr *-( this.rc(0, 1) * A2312 - this.rc(0, 2) * A1312 + this.rc(0, 3) * A1212 ),

                        dr *-( this.rc(1, 0) * A2323 - this.rc(1, 2) * A0323 + this.rc(1, 3) * A0223 ),
                        dr * ( this.rc(0, 0) * A2323 - this.rc(0, 2) * A0323 + this.rc(0, 3) * A0223 ),
                        dr *-( this.rc(0, 0) * A2313 - this.rc(0, 2) * A0313 + this.rc(0, 3) * A0213 ),
                        dr * ( this.rc(0, 0) * A2312 - this.rc(0, 2) * A0312 + this.rc(0, 3) * A0212 ),

                        dr * ( this.rc(1, 0) * A1323 - this.rc(1, 1) * A0323 + this.rc(1, 3) * A0123 ),
                        dr *-( this.rc(0, 0) * A1323 - this.rc(0, 1) * A0323 + this.rc(0, 3) * A0123 ),
                        dr * ( this.rc(0, 0) * A1313 - this.rc(0, 1) * A0313 + this.rc(0, 3) * A0113 ),
                        dr *-( this.rc(0, 0) * A1312 - this.rc(0, 1) * A0312 + this.rc(0, 3) * A0112 ),

                        dr *-( this.rc(1, 0) * A1223 - this.rc(1, 1) * A0223 + this.rc(1, 2) * A0123 ),
                        dr * ( this.rc(0, 0) * A1223 - this.rc(0, 1) * A0223 + this.rc(0, 2) * A0123 ),
                        dr *-( this.rc(0, 0) * A1213 - this.rc(0, 1) * A0213 + this.rc(0, 2) * A0113 ),
                        dr * ( this.rc(0, 0) * A1212 - this.rc(0, 1) * A0212 + this.rc(0, 2) * A0112 ),
                    ] );
                }
                static translation( dx, dy, dz ) {
                    
                    // return the translation matrix
                    return new Mat4([
                        1, 0, 0, dx,
                        0, 1, 0, dy,
                        0, 0, 1, dz,
                        0, 0, 0, 1
                    ]);
                }

                rc( row, col ) {
                    return this.data[ row * 4 + col ]
                }
                mul( right ) {
        
                    // return the result of multiplication
                    const result = [];
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            let sum = 0;
                            for (let k = 0; k < 4; k++) {
                                sum += this.rc(row, k) * right.rc(k, col);
                            }
                            result.push(sum);
                        }
                    }
                    return new Mat4(result);
                }
                
                static frustum( left, right, bottom, top, near, far ) { 
                    // these scalars will scale x,y values to the near plane
                    let scale_x = 2 * near / ( right - left );
                    let scale_y = 2 * near / ( top - bottom );

                    // shift the eye depending on the right/left and top/bottom planes.
                    // only really used for VR (left eye and right eye shifted differently).  
                    let t_x = ( right + left ) / ( right - left );
                    let t_y = ( top + bottom ) / ( top - bottom );

                    // map z into the range [ -1, 1 ] linearly
                    const linear_c2 = 1 / ( far - near );
                    const linear_c1 = near / ( far - near );
                    // remember that the w coordinate will always be 1 before being fed to the vertex shader.
                    // therefore, anything we put in row 3, col 4 of the matrix will be added to the z.

                    // map z into the range [ -1, 1], but with a non-linear ramp
                    // see: https://learnopengl.com/Advanced-OpenGL/Depth-testing and
                    // https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix and
                    // http://learnwebgl.brown37.net/08_projections/projections_perspective.html
                    // for more info. (note, I'm using left-handed coordinates. Some sources use right-handed).
                    const nonlin_c2 = (far + near) / (far - near);
                    const nonlin_c1 = 2 * far * near / (far - near);

                    let c1 = nonlin_c1;
                    let c2 = nonlin_c2;

                    return new Mat4( [
                        scale_x,    0,           t_x, 0,
                        0,          scale_y,     t_y, 0, 
                        0,          0,          c2, -c1,
                        0,          0,          1, 0, 
                    ] );
                }
            }
            function set_uniform_matrix4(gl, program, name, data) {
                const loc = gl.getUniformLocation(program, name);
                gl.uniformMatrix4fv(loc, false, data);
            }

            // Create a projection matrix
            let fov = Math.PI/2; // 90 degrees
            let aspect = canvas.width / canvas.height;
            let near = 1;
            let far = 1001;

            let topp = near * Math.tan(fov * 0.5);
            let bottom = -topp;
            let right = topp * aspect;
            let left = -right;

            let projectionMatrix = Mat4.frustum(left, right, bottom, topp, near, far);

            let camera = Mat4.identity().mul(Mat4.translation(0,0,-2));

            let mesh = Mesh.box(gl, shader_program, 1, 1, 1);

            let key = Keys.start_listening(document, canvas);
            
            setInterval(update, 1000/60)
            function update() {
                if (key.is_key_down('KeyA')) {
                    camera = camera.mul(Mat4.translation(-0.05, 0, 0));
                }
                return camera;
            }
            
            function render() {

                requestAnimationFrame(render); // Call the render function again

                gl.enable(gl.DEPTH_TEST);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                let model = projectionMatrix.mul(camera.inverse());

                // Update the shader uniform
                set_uniform_matrix4(gl, shader_program, "modelview", model.data);
                
                mesh.render(gl);
            }
            
            requestAnimationFrame(render);
        </script>
    </body>
</html>