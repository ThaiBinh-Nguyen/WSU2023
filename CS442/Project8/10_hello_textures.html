<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=XOsFHKOql8q0OaBnV1DspdS5NiUXsiztT1Kx-lBnBOwEmnl3rUZCPS-zAnyEcA5_Zd7HTtFYMApU6o5NMUeXt439QzeeusxtCD5GWNiJUVt622n5yGJToIqXjgWX5DLrJtsl46Y6acrugN-x83uvy1MrljN75Y6jM1Zyu2eYdIGcqNGIFEa2ahz6yWSyKbQKbLh39NlubdEJuIsJy0GmjS-Qs2dmVBxMMmuDf5LEXgQenn41d8AoHK1qaudDwcWXhN9VibeH_ozYzl7JoaQmn56-dOZc6utNR1uhKvf-oAtG1eiB4CciG_WhIzlKmIoXbqgy4qo8WVicH_jrBXv3RW4WBAoNtOFyp1JWcTUAo8nNRRh2ySFoae6rauVPEDFLcvrNO0R0VcwL35hQ2aq1uRZzIiOgjSIF9j6K0Q5522oXQRw2LheMIk_OAD0C059hjTEwhcHAwRsdsEyLqmZb0jtNp7OjWdWbcrezJz-SuosvedFG-9RJhcs8x2c3iFk_7PKR2NC9HIqHcQAAYJjwe6V5nxCY6rANFaJBhZO4MJp6yhE995Kv94BGzOpo2i2Z7wWS5VZEnaIQ4puq6zMS4GBPigF7i3ihvCxUbosXy7WYDGB2thWOuANSUiWoNR5xGA3Drmygdp6JJI0AqdgeRRHXiva_N_9mtCl1gNYplDx8Kd3NpPvY9PhroMyn5tnd" charset="UTF-8"></script><style>
            body { 
                display: flex;
                justify-content: center; 
                flex-direction: column;
            }
            canvas {
                width: 800;
                height: 600;
            }
            #render-button {
                width: 180px;
                height: 50px;
                font-size: 24pt;
            }
            #the-canvas { border: 1px solid darkblue; }
            #user-matrix input { width: 64px; font-size: 24px; }
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <script src = "lib.js"></script>
        <script src = "vector.js"></script>
        <script src = "matrix.js"></script>
        <script src = "uv_mesh.js"></script>
        <script src = "controls.js"></script>
        <script src = "cam.js"></script>
        <script src = "material.js"></script>
        <script>
            let canvas = document.getElementById( 'the-canvas' );
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );

            let vertex_source = 
            `   #version 300 es
                precision mediump float;

                uniform mat4 modelview;

                in vec3 coordinates;
                in vec4 color;
                in vec2 uv;

                out vec4 v_color;
                out vec2 v_uv;

                void main( void ) {
                    gl_Position = modelview * vec4( coordinates, 1.0 );
                    v_color = color;
                    v_uv = uv;
                }
            `;
            
            let fragment_source = 
            `   #version 300 es
                precision mediump float;

                in vec4 v_color;
                in vec2 v_uv;

                out vec4 f_color;

                uniform sampler2D tex_0;

                void main( void ) {
                    /* if we want to use colors, we can use this
                    f_color = v_color * texture( tex_0, v_uv ); */
                    f_color = texture( tex_0, v_uv );

                    /* we can test depth values with this.
                    f_color = vec4(vec3(gl_FragCoord.z), 1.0); */
                }
            `;


            let shader_program = 
                create_compile_and_link_program( gl, vertex_source, fragment_source );
            gl.useProgram( shader_program );

            set_render_params( gl );

            let last_update = performance.now();

            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000.0 / DESIRED_TICK_RATE;

            const ROTATION_SPEED = 0.125; // eighth turn per second
            const ROTATION_SPEED_PER_FRAME = ROTATION_SPEED / DESIRED_TICK_RATE;

            const FLY_SPEED = 1;    // units per second
            const FLY_SPEED_PER_FRAME = FLY_SPEED / DESIRED_TICK_RATE;

            let keys = Keys.start_listening();
            let cam = new Camera();
            cam.translate( 0, 0, -1.5 );

            
            // let metal = new Material( gl, 'tex/metal_scale.png', gl.LINEAR );
            // let metal = new Material( gl, 'tex/metal_scale.png', gl.LINEAR_MIPMAP_NEAREST );
            let metal = new Material( gl, 'tex/metal_scale.png', gl.NEAREST );
            let metal_psx = new Material( gl, 'tex/metal_scale_psx.png', gl.LINEAR );
            let grass = new Material( gl, 'tex/grass_lawn_seamless.png', gl.LINEAR );
            let mapped = new Material( gl, 'tex/texture_map.png', gl.LINEAR_MIPMAP_LINEAR );

            // let mesh = UvMesh.box( gl, shader_program, 1, 1, 1, metal_psx );
            let mesh = UvMesh.mapped_box( gl, shader_program, 1, 1, 1, mapped );

            let projection = Mat4.perspective_fovx( 0.25, 4 / 3, 0.125, 128 );

            function render( now ) {
                requestAnimationFrame( render );

                last_update = now;
                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

                // still treating projection separately
                let model = Mat4.identity();
                model = model.mul( projection );
                model = model.mul( cam.get_view_matrix() );
                
                set_uniform_matrix4( 
                    gl, shader_program, "modelview", model.data );

                mesh.render( gl );
            }

            const KEYMAP = {
                'KeyW': function() { cam.move_in_direction( 0, 0, FLY_SPEED_PER_FRAME ); },
                'KeyS': function() { cam.move_in_direction( 0, 0, -FLY_SPEED_PER_FRAME ); },
                'KeyA': function() { cam.move_in_direction( -FLY_SPEED_PER_FRAME, 0, 0 ); },
                'KeyD': function() { cam.move_in_direction( FLY_SPEED_PER_FRAME, 0, 0 ); },
                'Space': function() { cam.translate( 0, FLY_SPEED_PER_FRAME, 0 ); },
                'KeyC': function() { cam.translate( 0, -FLY_SPEED_PER_FRAME, 0 ); },
                'KeyQ': function() { cam.add_roll( -ROTATION_SPEED_PER_FRAME ); },
                'KeyE': function() { cam.add_roll( ROTATION_SPEED_PER_FRAME ); },
                'ArrowLeft': function() { cam.add_yaw( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowRight': function() { cam.add_yaw( ROTATION_SPEED_PER_FRAME ); },
                'ArrowUp': function() { cam.add_pitch( -ROTATION_SPEED_PER_FRAME ); },
                'ArrowDown': function() { cam.add_pitch( ROTATION_SPEED_PER_FRAME ); },
            };

            function update() {
                let keys_down = keys.keys_down_list();

                for( const key of keys_down ) {
                   let bound_function = KEYMAP[ key ];

                   if( bound_function ) {
                       bound_function();
                   }
                }

                return;
            }
            
            

            requestAnimationFrame( render );
            setInterval( update, DESIRED_MSPT );
        </script>
    </body>
</html>